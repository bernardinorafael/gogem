package uid

import (
	"crypto/rand"
	"encoding/binary"
	"fmt"
	"regexp"
	"strings"
	"time"
)

const epochTimestampInSeconds = 1700000000

// New generates a unique identifier with an optional prefix.
//
//	// Generate an ID with a custom prefix
//	id := uid.New("invoice") // returns "invoice_1z4UVH4CbRPvgSfCBmheK2h8xZb"
//
//	// Generate an ID without a prefix
//	id := uid.New("") // returns "1z4UVH4CbRPvgSfCBmheK2h8xZb"
func New(prefix string) string {
	buf := make([]byte, 12)
	t := uint32(time.Now().Unix() - epochTimestampInSeconds)
	binary.BigEndian.PutUint32(buf[:4], t)

	_, err := rand.Read(buf[4:])
	if err != nil {
		panic(err)
	}

	if prefix == "" {
		return fmt.Sprintf("%x", buf)
	}

	return fmt.Sprintf("%s_%x", prefix, buf)
}

// IsValid validates if a string is a valid UID generated by this package
// Supports both formats: "24hex_chars" or "prefix_24hex_chars"
func IsValid(uid string) bool {
	if uid == "" {
		return false
	}
	if strings.Contains(uid, "_") {
		parts := strings.SplitN(uid, "_", 2)
		if len(parts) != 2 || parts[0] == "" || parts[1] == "" {
			return false
		}
		return regexp.MustCompile(`^[a-f0-9]{24}$`).MatchString(parts[1])
	}
	return regexp.MustCompile(`^[a-f0-9]{24}$`).MatchString(uid)
}
